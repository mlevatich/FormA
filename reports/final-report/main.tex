\documentclass{article}

\usepackage{xspace}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}

\newcommand{\LTLglobally}{\Box}
\newcommand{\LTLeventually}{\Diamond}
\newcommand{\LTLnext}{\bigcirc}
\newcommand{\Name}{\textit{FormA}\xspace}
\newcommand{\cbmc}{\texttt{CBMC}}
\newcommand{\sdl}{\texttt{SDL}}

\title{COMS 6863 Final Project Status Report: \Name{}}
\author{
    Max Levatich$^*$ \& Wonhyuk (Harry) Choi
}
\date{\today}

\begin{document}
\maketitle

\section{Introduction}

    Our aim was to design, program, and verify via model-checking a lightweight
	video game called \Name{}, \emph{Formal verified Asteroids}.
	\Name is based loosely on the classic arcade game \textit{Asteroids}
    \cite{asteroids}; the player controls a small spaceship, viewed from a
    top-down perspective, and must avoid or shoot down incoming asteroids from
    all directions.

    \Name{} is implemented in C, with the help of the low-level rendering and
    audio library \sdl{}. We used \cbmc{} \cite{clarke2004tool} to model-check
    certain properties of the game as we developed it, including memory safety,
    collision pruning correctness, velocity limits, and sprite boundary zones.

    \subsection{Deliverables}

        We submit:

        \begin{enumerate}
            \item{The game's code and assets}
            \item{Build instructions, including how to invoke \cbmc{}}
            \item{A final project report detailing our process and a correctness
            specification of the properties checked}
        \end{enumerate}

        We also created demo videos of our gameplay, available in two versions:

        \begin{itemize}
            \item The basic gameplay video, available at link \url{
        			https://www.youtube.com/watch?v=PcLxyKBAmO4
            }
            \item The gameplay video with ``bounded boxes'' used for collision detection, available at link \url{
        			https://www.youtube.com/watch?v=oIl8qvB_IzI
            }
        \end{itemize}

        \begin{figure}[h!]
            \includegraphics[width=\linewidth]{gameplay.png}
            \caption{Screenshot of \Name{}}
            \label{fig:gameplay}
        \end{figure}

    \subsection{Comparison with our proposal}

        As we laid out in our project proposal, we successfully implemented
        \Name{} (Figure~\ref{fig:gameplay}), a safe and finely tuned variant of
        \textit{Asteroids}, entirely from scratch with an eye towards model
        checking through the whole development process. \Name{} surpasses the
        original game in features, and is comparable in scope to modern variants
        found on the internet, complete with scoring, sound effects, music, six
        degrees of freedom per sprite, and robust collision detection.
        Furthermore, we model-check a number of technically non-trivial and
        practically useful properties of the game using \cbmc{}, including
        properties not mentioned in our proposal, which we came up with during
        development. \cbmc{} and \texttt{clang-tidy}, paired with our other
        testing approaches, allowed us to find subtle bugs in our
        implementation, such as memory leaks and overly permissive collision
        detection.

        While the game as written is fully featured and fun to play, we were not
        able to pursue the extensions discussed in our proposal, such as
        non-fatal collisions with "bouncy" objects, or objects with their own
        gravitational fields. While these features would certainly be cool, we
        feel that \Name{} as written, coming in at 1000 lines of code, is
        complex enough to present interesting model-checking challenges for
        the purposes of CSEE 6863.

    \subsection{Author contributions}

        Both authors contributed equally to the project. Max focused
        on writing the game loop and interfacing with SDL for graphics and
        audio, and defining the \sdl{} interface for \texttt{mockSDL.h}. Harry
        focused on determining appropriate logic formulas to verify,
        implementing those formulas, and instrumenting our build to support
        \cbmc{} and \texttt{clang-tidy}. Both authors worked on the core
        collision detection algorithms, as well as drafting the reports and
        presentation.

\section{Implementation overview}

    \subsection{Development environment}

        \Name{} is written in C (C11 standard) and depends only on \cbmc{} and
        Simple DirectMedia Layer 2.0 (\sdl{}), along with supplementary
        extensions \texttt{SDL Mixer} and \texttt{SDL TTF}. \sdl{} is a
        development library written in C which provides a simple low-level
        interface to the keyboard, audio, and graphics hardware necessary to
        program a video game.

    \subsection{Implementation details}

        In \Name{}, the player will use the arrow keys on the keyboard to
        control a ``spaceship''. The up arrow applies a force to the ship in the
        direction that it is facing, while the left and right arrows turn the
        ship in place. This allows the player to navigate a 2D plane which wraps
        around. Asteroids will spawn randomly outside of the boundaries of the
        space with fixed velocities and the player must avoid them or shoot them
        using the spacebar, which will fire a bullet in the direction the ship
        is facing. Staying alive and shooting down asteroids increases the
        player's score. Contact with an asteroid results in a game-over.

        Many of the game's central mechanics revolve around collision detection
        and resolution.

        For collision detection, we will use an Axis-Aligned Bounding Box (AABB)
        algorithm with fine-grained boxes. To enable fine-grained boxes, we may
        also explore classical collision detection optimizations, which prune
        the $n^2$ space of all potential collisions (one for each pair of
        objects) into a set of \textit{candidate} collisions for objects which
        are efficiently determined to be reasonably close
        \cite{moore1988collision, palmer1995collision}. Should we implement any
        optimizations, we will aim to use model checking to show that the
        optimizations are correct; that is, they do not prune any collisions
        which should have happened on a particular frame.

\section{Correctness Specification}
\label{sec:properties}

    We chose several CTL properties to check for our game.
    The specifications changed and grew as we discovered what kinds of properties we can effectively check, and we came up with the following CTL formulas for model checking.

    \subsection{Collision Handling}

        $$AG(\forall obj. obj \neq ship \implies \lnot touching(obj,ship))$$
        In practice, we had to approximate this property by having two separate collision handling checks: an \emph{underapproximation} and an \emph{overapproximation}.
        This is detailed further in Section \ref{sec:collision}.

    \subsection{Input Correspondance}

        $AG(keydown(UP) \implies ship.fx = -sin(ship.theta) * ACCEL\_NORM
                        \land ship.fy = cos(ship.theta) * ACCEL\_NORM)$

        $AG(keydown(LEFT) \land \lnot keydown(RIGHT) \implies ship.omega = ANGULAR\_VEL)$

        $AG(keydown(RIGHT) \land \lnot keydown(LEFT) \implies ship.omega = -ANGULAR\_VEL)$

        $AG(keydown(LEFT) \land keydown(RIGHT) \implies ship.omega = 0)$

	\subsection{Asteroid Leaves Screen}

		\begin{align*}
			AG((asteroid.x < 0 \lor end < asteroid.x) \land
			(asteroid.y < 0 \lor end < asteroid.y))
		\end{align*}

    \subsection{Asteroids Always Exist}
    \[AG(asteroids != NULL)\]

    \subsection{Ship is Always in Screen}
    \begin{gather*}
        -shipWidth \leq shipX \land shipX \leq SCREEN\_WIDTH + shipWidth \land \\
        -shipHeight \leq shipY \land shipY \leq SCREEN\_HEIGHT + shipHeight
    \end{gather*}

    \subsection{Laser is Always Faster than Ship}
    $$AG(shipVelocity~<~laserVelocity)$$

\section{Verification Approach}

    To verify our correctness specification (Section 3), we will use the C
    Bounded Model Checker (CBMC). CBMC is capable of statically checking the
    validity of assertions in a C program by unrolling paths through the
    program.

    We plan to express the propositional logic formulas in our correctness
    specification as assertions, preconditions, and postconditions, such that
    CBMC can check them. These assertions will be invoked on every iteration of
    the \textit{game loop}, such that from a zoomed-out perspective where each
    frame of the game is a state transition, they can be viewed as AG() CTL
    formulas.

	We plan to integrate CBMC as a developmental procedure, just like regression testing might be used in a software development cycle.
	Creating the assertions themselves will help with the design process, and model checking will show that we have the correct implementation with respect to the specification.

\subsection{Comparison with \texttt{clang-tidy}}
We also employed the tool \texttt{clang-tidy} to catch possible bugs through static analysis.
Most notably, it was able to show a null pointer dereference that we had in our code (Figure~\ref{fig:clang-tidy})
\begin{figure}[h!]
    \includegraphics[width=\linewidth]{clang-tidy.png}
    \caption{Using \texttt{clang-tidy}}
    \label{fig:clang-tidy}
\end{figure}

\subsection{Using \cbmc}
\subsubsection{Creating interface API for \cbmc}
In order to use \cbmc, we were forced to de-couple the implementation of our game with its graphical implementation.
When we try to invoke \cbmc on the \texttt{SDL} library, even with the simplest code listing as below:
\begin{verbatim}
#include<SDL2/SDL.h>
int main(){}
\end{verbatim}
results in an error as shown in Figure~\ref{fig:cbmc-sdl}, even though the code runs properly.

\begin{figure}[h!]
    \includegraphics[width=\linewidth]{cbmc-sdl.png}
    \caption{Error with SDL2 and CBMC}
    \label{fig:cbmc-sdl}
\end{figure}

We decided to create a mock interface that has the same definitions of the library, without its implementations,
since we were not interested in checking the correctness of the \texttt{SDL} library.
A sample mock interface is shown in Figure~\ref{fig:mock-sdl}, where the SDL functions we use are all no-op functions or return \texttt{NULL}.
This allowed us to decouple the implementation of SDL (which presumably has some errors in model checking against the default cbmc settings) and the actual implementation of our project.

\begin{figure}[h!]
    \includegraphics[width=\linewidth]{mock-sdl.png}
    \caption{MockSDL Interface}
    \label{fig:mock-sdl}
\end{figure}

\subsubsection{Writing good properties}
We found that writing properties was actually difficult -- creating the specification of the project was a major problem.
What property do we want to check in the game?
We had to think of possible bugs that can happen in the game.
What is the ``specification'' of the game?

Ultimately, we were able to come up with several properties that we describe in Section~\ref{sec:properties}.

\subsubsection{Limited size checking of BMC}
As with all code, our codebase heavily relies on loops, and this exploded the size of our problem.
Even when we ran loops with depth $2$, they were heavily nested and took more than ten minutes to run.

This became even more an issue when we wanted to check for \emph{reachability properties}.
When we wanted to check the property that ``every asteroid eventually leaves the screen,'' we could not write this reachability property directly, so we wanted to model check it for a large number of bounds, e.g. $100$.
However, this made the automata size very large, and caused the model checker to run out of memory (Figure~\ref{fig:killed}).
Eventually, we had to make do without adding this property into our check.

\begin{figure}[h!]
    \includegraphics[width=\linewidth]{killed.png}
    \caption{Out of Memory}
    \label{fig:killed}
\end{figure}

Additionally, we wanted to check properties that are preserved across different functions calls (e.g. that the plane and the laser never collide), and so it was not always possible to instantiate environment assumptions for each function call.


\subsubsection{Debugging long error traces}
When we were able to find violations in our properties, we found that the counterexample traces that we found were very long.
For instance, for checking that our ship was in bounds, we obtained a counterexample trace (cf. Appendix ~\ref{appendix:trace}) that was $199$ transitions long,
This made debugging the property very difficult, even when using the \texttt{--compact-trace} option --
although perhaps a subtle error that we would not have been able to obtain without formal verification.

\section{Collision Detection}
\label{sec:collision}
Collision Detection was the main property we were model checking.
\textcolor{red}{
    TODO
}
\textcolor{blue}{
    \begin{itemize}
        \item Collision detection is hard
        \item Overapproximation
        \item Underapporximation
    \end{itemize}
}

\section{Presentation}
The presentation can be accessed at the following link: \url{https://docs.google.com/presentation/d/1bMOITxPOLg-2RSm_nAAHFMOQ0pkXzM3FMqpCxDSlm5w/edit?usp=sharing}.

\bibliographystyle{IEEEtran}
\bibliography{proposal}

\appendix
\section{Counterexample Trace for Property Violation}
\label{appendix:trace}
\include{trace}

\end{document}
